<!--  
 *     The contents of this file are subject to the Initial 
 *     Developer's Public License Version 1.0 (the "License"); 
 *     you may not use this file except in compliance with the 
 *     License. You may obtain a copy of the License at 
 *     http://www.ibphoenix.com/main.nfs?a=ibphoenix&page=ibp_idpl
 *
 *     Software distributed under the License is distributed on 
 *     an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
 *     express or implied.  See the License for the specific 
 *     language governing rights and limitations under the License.
 *
 *
 *  The Original Code was created by Vladimir Tsvigun for IBPhoenix.
 *
 *  Copyright (c) 2004 Vladimir Tsvigun
 *  All Rights Reserved.
 *
 *  This editing was done by Paul Beach of IBPhoenix
 *
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1251">
<TITLE>Транзакции</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<P><A NAME="hid_transactions"></A><h2>Транзакции</h2></P>

<P>Firebird поддерживает следующие уровни изоляции транзакции:</P>

<P><UL>	1 (read committed, the default),<BR>
	2 (serializable)<BR>
	3 (versioning). </UL></P>

<P>Firebird осуществляет блокировку уровня строки во всех случаях.</P>

<P>Firebird выполняет оптимистическую блокировку. Ваша транзакция не пытается
блокировать запись, пока Вы не выдаете операцию модификации, которая 
воздействует на ту запись. Это означает, что это возможно, хотя редко, 
для вашей модификации, чтобы терпеть неудачу, потому что другой клиент 
блокировал запись, даже если Вы начали вашу транзакцию раньше чем другой клиент.</P>

<P>Firebird использует уникальный версионный двигатель, чтобы достигнуть 
степени детализации более тонко чем обеспечение традиционной блокировкой
уровня строки. Версионный двигатель позволяет любому числу клиентуры читать
непротиворечивую копию любой данной записи, даже если в то же самое время
другой клиент модифицирует ту же самую строку. Читающие и пишущие одну и туже
запись никогда не блокируют друг друга.</P>


<P>
Начиная с версии v2.0, Firebird ODBC поддерживает все без исключения типы
транзакций, которые может обеспечить сервер, включая блокирование таблиц.
Для этого был добавлен SQL синтаксис(GPRE), который выполняется 
ODBC API функцией SQLExecDirect.</P>

<A name=IND_SQL_TRANSACTION></A>
<P>Полная форма запроса:</P>
<P><B>
SET|DECLARE TRANSACTION [LOCAL] [NAME transaction [USING nameUniqueWorkspase]]<BR>
[READ WRITE | READ ONLY]<BR>
[WAIT | NO WAIT]<BR>
[AUTOCOMMIT]<BR>
[NO_AUTO_UNDO]<BR>
[[ISOLATION LEVEL] {SNAPSHOT [TABLE STABILITY] or REPEATABLE READ<BR>
| SERIALIZABLE<BR>
| READ COMMITTED [[NO] RECORD_VERSION]}]<BR>
[RESERVING 'reserving_clause'];</B></P>

<P><B>'reserving_clause' = table [, table :]<BR>
[FOR [SHARED | PROTECTED] {READ | WRITE}] [, <reserving_clause>]</B></P>

<P>Назначение и описание.</P>

<A name=IND_DECLARE_TRANSACTION></A>
<P><B>DECLARE TRANSACTION...</B> - декларируем описание транзакции, без ее выполнения.</P>

<P><B>SET TRANSACTION...</B> - ставим транзакцию на выполнение, выключая глобальную
установку <B>SQL_ATTR_AUTOCOMMIT</B> в положение <B>SQL_AUTOCOMMIT_OFF</B>. После
завершения текущей будет работать указанная.<BR>
<B>LOCAL</B> - определяет выполнение транзакции в пределах активного оператора(запроса).<BR>
<B>NAME transaction</B> - уникальное имя транзакции, по которому формируется.
в глобальном окружении соединений таблица транзакции подготовленных на выполнение.<BR>
<B>USING nameUniqueWorkspase</B> - уникальное имя рабочего пространства транзакции, 
по которому формируется в глобальном окружении соединений таблица транзакции
подготовленных на выполнение, имея два активных соединения, которые могут иметь 
одинаковые названия транзакций, но разные их описания.</P>

<P>
<B>DECLARE TRANSACTION ... [NAME transaction [USING nameUniqueWorkspase]]</B>
<BR> 
  Эта форма записи предназначена для предварительной подготовки описаний
транзакций, которые сохраняются в глобальном окружении соединений. Это
экономит время и позволяет многократно использовать для любого активного
соединения. Вызов такой транзакции на выполнение выполняется командой:
<P>
 - для соединения<UL>

	<B>SET TRANSACTION NAME MyReadTransaction</B><BR>
    или<BR>
	<B>SET TRANSACTION NAME MyReadTransaction USING MyDsnDb1</B></UL>
</P>

<P>
 - для отдельного запроса в пределах одного соединения<UL>

	<B>SET TRANSACTION LOCAL NAME MyReadTransaction</B><BR>
    или<BR>
	<B>SET TRANSACTION LOCAL NAME MyReadTransaction USING MyDsnDb1</B><BR>

    и в этом же соединение, для другого запроса<BR>

	<B>SET TRANSACTION LOCAL NAME MyWriteTransaction</B><BR>
    или<BR>
	<B>SET TRANSACTION LOCAL NAME MyWriteTransaction USING MyDsnDb1</B></UL><BR>
</P>
<P>
<B>SET TRANSACTION ... [NAME transaction [USING nameUniqueWorkspase]]</B><BR>
 
  Эта форма записи отличается от предыдущей тем, что ставит транзакцию
на выполнение, после завершения активной, если такая имеется. Однако
если указано ключевые слова <B>NAME</B> или <B>USING</B>, тогда эта транзакция может
так же многократно вызываться уже только с указанием ее имени.

Примечание. Для возврата в обычный режим работы, необходимо выполнить
переоткрытие соединения. </P>
  
<P>
  Так же, добавлено обслуживание SQL запросов <B>COMMIT</B> и <B>ROLBACK</B>, эти
вызовы выполняют ту же работу что и основной вызов <B>SQLEndTran</B>.

  Есть программы, которые умеют вызывать SQLExecDirect и не 
умеют вызывать SQLEndTran. Для этих программ нужно ставить вызов<BR>
       <UL><B>SQLExecDirect( hStmt, "COMMIT" )</UL></B>
что гарантированно обеспечит вызов:
       <UL><B>SQLEndTran( SQL_HANDLE_DBC, hConnection, SQL_COMMIT );</UL></B>
Однако, если транзакция была инициированна локально, тогда
драйвер выполнит <B>SQLEndTran</B> для локального <B>hStmt</B>.</P>

	<P><h2>Two Phase Commit Transactions</h2></P>

<P>Эта возможность позволяет максимально на 16 разных Firebird базах данных 
выполнять commit(совершать) транзакции. Например, используя инструкцию<BR></P>

<UL><B>SQLSetConnectAttr (connection, 4000, (void*) TRUE, 0);</B></UL>

<P>Вы сообщаете Firebird ODBC, что это соединение должно участвовать в
схеме "two  phase  commit  transactions". Подключив этой командой несколько
соединений и выполняя на любом соединении Commit или Rollback, Вы получите
схему "two  phase  commit  transactions". Для исключения соединения из схемы
используйте инструкцию:</P>

<UL><B>SQLSetConnectAttr (connection, 4000, (void*) FALSE, 0); </B></UL>

<A name=IND_MANY_TRANSACTIONS></A>
<P><h2>Пример использования разных транзакций в одном соединении</h2></P>


<P><PRE>
    HSTMT stmtRd;
    HSTMT stmtWr;

    SQLAllocHandle( SQL_HANDLE_STMT, connection, &stmtRd );
    SQLAllocHandle( SQL_HANDLE_STMT, connection, &stmtWr );

    SQLExecDirect( stmtRd, (UCHAR*)
		   "SET TRANSACTION LOCAL\n"
		   "READ ONLY\n"
		   "ISOLATION LEVEL\n"
		   "READ COMMITTED RECORD_VERSION WAIT\n",
		   SQL_NTS );

    SQLExecDirect( stmtWr, (UCHAR*)
		   "SET TRANSACTION LOCAL\n"
		   "READ WRITE\n"
		   "ISOLATION LEVEL\n"
		   "READ COMMITTED RECORD_VERSION WAIT\n",
		   SQL_NTS );

    SQLExecDirect( stmtRd,(UCHAR*)
		   "SELECT CURRENCY FROM COUNTRY"
		   "   WHERE country = 'Canada'"
		   "   FOR UPDATE OF CURRENCY",
		   SQL_NTS );

    SQLFetch( stmtRd );

    SQLPrepare( stmtWr, (UCHAR*)
		"update COUNTRY\n"
		"set    CURRENCY = 'CndDlr'\n"
		"where  COUNTRY = 'Canada'\n",
		SQL_NTS );

    SQLExecute( stmtWr );

    SQLExecDirect( stmtWr, (UCHAR*)"COMMIT", SQL_NTS );

</P></PRE>


<P>Для более подробного ознакомления с этими и другими возможностями
пожалуйста, рассмотрите примеры.
</P>

</BODY>
</HTML>
